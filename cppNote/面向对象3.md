# 面向过程与面向对象

> 所谓面向对象编程，并没有多数人想象中的复杂，通俗来讲是另一种思考问题、解决问题的另一种方式

C语言众所周知是一门典型的面向过程高级语言，而CPP、Java、Python等是面向对象编程的高级语言，这里面向对象并不对编程语言有要求，并不是C语言写不出面向对象的编程，你可以利用C语言中的关键字`struct`构造一个结构体，也是可以写出带有面向对象思想的编程的。而上述其他高级语言往往在设计之初便考虑到面向对象编程的需求，更加支持面向对象编程，然而，用这些高级语言也可以写出面向过程的编程。

+ 面向过程编程重点在于解决问题的一步步实现，更在意实现步骤是怎么实现的
+ 面向对象编程重点在于在看待问题时如何在问题中抽象出问题的实体，利用实体去解决问题

## 如何将大象装进冰箱

+ 面向过程
   + 1. 打开冰箱门
       2. 将大象装进冰箱
       3. 关闭冰箱门
+ 面向对象
   + 抽象出实体：大象类、冰箱类
   + 1. 冰箱使用开冰箱门的方法
       2. 冰箱使用将实体放入冰箱的方法，实体为大象。或者大象使用进入实体的方法，实体为冰箱
       3. 冰箱使用关闭冰箱门的方法

# 类与对象

==在面向对象的编程思想中==，问题重点在于抽象出可以解决问题的实体，使用这个实体去解决问题，这个过程中的实体称为**对象**

也就是说：

具有特定的功能，可以解决问题的一个实体，称为**对象**

由若干个具有相似特征和行为的对象组成的集合，称为**类**

> 类是对象的集合，对象是类的个体

比如：

+ 大象类

   1. 亚洲大象
   2. 非洲大象
   3. 美洲大象

+ 人类

   1. 亚洲人
   2. 美洲人
   3. 非洲人

   

# 类的设计

从若干个具有相同特征和行为的对象中，提取出共同的特征和行为，可以设计出一个**类**。

类中定义出所有对象的共有特征和行为，其中，特征用**属性**表示，行为用**方法**表示。

> 通常来讲，属性就是变量，方法就是函数

比如现在要设计人类，那么就要首先考虑人具有的特征：姓名、性别、年龄、体重；人具有的行为：吃饭、睡觉

## 类中的访问权限

设计一个类，除了考虑特征和行为之外，还要为这些特征和行为设置访问权限，也就是说，访问权限就是用来设置这些特征和行为可以在什么位置被访问

+ `public`：公开，所有人均可访问
+ `private`：私有权限，仅能够在当前类内可访问
+ `protected`：保护权限，仅可在当前类内或子类中访问

如果在设计类的时候没有主动设置访问权限，编译器会默认选择`private`

## 设计一个人类

```cpp
class Person {
	public:
		string name;
		string gender;
		int age;
		int height;

		void sleep() {
			cout << "人类睡觉" << endl;
		}

		void eat() {
			say();
			cout << "人类吃饭" << endl;
		}
	private:
		void say() {
			cout << "我是嫌疑人X" << endl;
		}
};

int main() {
	Person x;
	x.sleep();
//	x.say();//[Error] 'void Person::say()' is private within this context
	x.eat();
  return 0;
}
```



# 对象的创建

## 在栈上开辟空间

```cpp
Person xiaoming = Person();//显式调用
//或
person xiaoming;//隐式调用
```

+ 函数或程序执行完毕后，自动销毁该对象，释放内存
+ 属性没有初始值
+ 通过`.`来访问对象



## 在堆上开辟

```cpp
Person *xiaoming = new Person();
```

+ 类似C语言中一个结构体指针的使用
+ 需要手动`delete`销毁
+ 自动有默认的初始值
+ 通过`->`访问对象



# 成员访问

对成员的访问和C语言中结构体的使用基本相同，类也就是一种自定义的数据结构，可以说，`class`其实就是一种升级版的`struct`，需要注意：

1. 类内成员的访问权限
2. 创建对象时的创建方式决定对象的使用语法

```cpp
class Dog {
	public:
		string name;
};
class Person {
	public:
		string name;
		string gender;
		int age;
		int height;
		Dog *huahua;

};

int main() {
	Person xiaoming;
	cout<<sizeof(xiaoming)<<endl;
//	xiaoming.huahua->name = "huahua";
//	cout<<xiaoming.huahua->name<<endl; [error]no print, need new a space
	xiaoming.huahua = new Dog();
	xiaoming.huahua->name = "huahua";
  //等价于(*xiaoming.huahua).name = "huahua";
	cout<<xiaoming.huahua->name<<endl;
	return 0;
}
```



# 实例

## 教师让学生做自我介绍

```cpp
#include <iostream>
using namespace std;
// 例一：教师让学生做自我介绍
// 1.抽象出具体类：教师类、学生类
// 2.为类添加属性和方法
// 3.创建对象
// 4.解决问题
class Student {
	public:
		string name;
		string gender;
		int age;
		int score;
		void introduceSelf() {
			cout << "大家好我是" << name << ", 性别" << gender << ", 今年" << age << "了，这次考试得分" << score << endl;

		}
};
class Teacher {
	public:
		string name;
		void makeIntroduce(Student s){
			s.introduceSelf();
		}
};
int main(){
	Student *xiaoming = new Student();
	xiaoming->name = "xiaoming";
	xiaoming->gender = "male";
	xiaoming->age = 18;
	xiaoming->score = 99;
	
	Teacher *laowang = new Teacher();
	laowang->name = "laowang";
	laowang->makeIntroduce(*xiaoming);
	
	delete xiaoming;
	delete laowang;
	
	return 0;
}
```



## 判断二维坐标系中一个点是否在一个圆内

```cpp
#include <iostream>
#include <cmath>
using namespace std;
// 例二：判断二维坐标系中一个点是否在一个圆内
// 1.抽象出具体类：点类、圆类
// 2.为类添加属性和方法
// 3.创建对象
// 4.解决问题
class Pointer {
	public:
		double x;
		double y;
};
class Circle {
	public:
		double radius;
		Pointer center;
		bool isContainer(Pointer p) {
			return sqrt(pow(p.x - center.x, 2) + pow(p.y - center.y, 2)) <= radius;
		}
};
int main() {
	Pointer p;
	p.x = 5.3;
	p.y = 5.7;

	Circle c;
	c.center.x = 2.1;
	c.center.y = 2.5;
	c.radius = 5;

	if (c.isContainer(p)) {
		cout << "该点在此圆内" << endl;
	} else cout << "该点不在圆内" << endl;

	return 0;
}
```

# 类外和其他文件中实现类函数

在一个大的CPP项目工程内，往往会将一个类单独写出一个.cpp文件和一个.h头文件，以分离式编译完成工程

+ 在类外实现类函数

```cpp
class Dog {
	public:
		string name;
		void say() {
			cout << "汪汪汪！" << endl;
		}
		void eat();
};
void Dog::eat() {
	cout << "需要吃饭！" << endl;
}
int main() {
	Dog huahua;
	huahua.say();
	huahua.eat();
	return 0;
}
```

+ 在其他文件中实现类函数

以DEV-CPP为例：

点击文件->新建->类

![image-20240121113400390](C:/Users/Exiler/AppData/Roaming/Typora/typora-user-images/image-20240121113400390.png)

新建一个Person类：

![image-20240121113519359](C:/Users/Exiler/AppData/Roaming/Typora/typora-user-images/image-20240121113519359.png)

类的实现文件名和头文件名也会自动创建，选择加入该项目

![image-20240121113639913](C:/Users/Exiler/AppData/Roaming/Typora/typora-user-images/image-20240121113639913.png)

IDE会自动添加到该项目，并作出一些预处理

1. **头文件（.h）：**

   - **声明类的结构：** 头文件包含了类的声明部分，其中**定义了类的成员变量、成员函数以及可能的其他相关声明。这相当于对外宣告了这个类的接口，使得其他源文件可以引用这个类而无需知道其具体实现细节。** **（封装特性）**
   - **防止重复包含：** 头文件通常包含防范重复包含的预处理指令，例如 `#ifndef`、`#define`、`#endif` 组合，以防止同一个头文件被多次引用。

   ```cpp
   // MyClass.h
   #ifndef MYCLASS_H
   #define MYCLASS_H
   
   class MyClass {
   public:
       // 成员函数声明
       void myFunction();
       
   private:
       // 成员变量声明
       int myVariable;
   };
   
   #endif // MYCLASS_H
   ```

2. **源文件（.cpp）：**

   - **实现类的方法：** 源文件包含了类成员函数的实现部分。这里定义了在头文件中声明的各个成员函数的具体实现，包括函数体内的代码。
   - **包含相关的头文件：** 在源文件中，你可能需要包含相关的头文件，以便使用其他类或库的功能。这可以通过 `#include` 指令实现。

   一个简单的类源文件的结构可能如下所示：

   ```cpp
   // MyClass.cpp
   #include "MyClass.h"
   
   // 成员函数的具体实现
   void MyClass::myFunction() {
       // 实现代码
   }
   ```

通过这种方式，头文件提供了类的接口，允许其他代码使用类的功能，而源文件则包含了实现细节。这种分离的设计使得在修改类的实现时，只需重新编译源文件，而不需要重新编译引用了该类的其他源文件，提高了代码的可维护性和可扩展性。

## 实例

+ `Person.h`

```cpp
#ifndef PERSON_H
#define PERSON_H
#include <iostream>
using namespace std;
class Person
{
	public:
		string name;
		int age;
		void sleep();
};

#endif
```

+ `Person.cpp`

```cpp
#include "Person.h"
void Person::sleep(){
	cout<<"人需要睡觉"<<endl;
}
```

+ `mian.cpp`

```cpp
#include "Person.h"
int main(){
	Person xiaoming;
	xiaoming.sleep();
}
```

### 使用GCC编译

```bash
g++ -o a.out Person.cpp main.cpp
```

### 使用MakeFile

```bash
#1.先创建一个名为MakeFile的文件

# Makefile
a.out: Person.o main.o
    g++ -o a.out Person.o main.o

Person.o: Person.cpp Person.h
    g++ -c Person.cpp

main.o: main.cpp Person.h
    g++ -c main.cpp

clean:
    rm -f *.o a.out

```

然后在终端运行

```bash
make
```

### 使用CMake

```bash
#1.创建一个名为CMakeLists.txt的文件

# CMakeLists.txt

cmake_minimum_required(VERSION 3.10)
project(MyProgram)

set(CMAKE_CXX_STANDARD 11)

add_executable(a.out Person.cpp main.cpp)  

# 设置可执行文件属性
set_target_properties(a.out PROPERTIES OUTPUT_NAME myprogram)
```

然后在终端运行

```bash
cmake .
make
```





# 构造函数

构造函数是一种类内的特殊成员函数，它在创建类的新对象时自动执行，主要用途是为新对象的创建的属性初始化赋值。

构造函数有一下特点：

1. 构造函数的名称与类名完全相同
2. 构造函数不会返回任何类型，也不会返回`void`
3. 构造函数可以通过不同的形参实现重载(`overload`)

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
  	//无参的构造函数
		Person() {
			cout << "Person对象被成功创建！" << endl;
		}
  	//带参的构造函数
		Person(string na_me, int a_ge) {
			name = na_me;
			age = a_ge;
			cout << "对象的姓名：" << name << ", 今年" << age << "岁了。" << endl;
		}
};
int main() {
	Person lihua;
	Person xiaoming = Person("xiaoming", 18);
	cout << xiaoming.name << " " << xiaoming.age << endl;
	return 0;
}
//Person对象被成功创建！
//对象的姓名：xiaoming, 今年18岁了。
//xiaoming 18
```

+ ---

+ ***在C++中，如果你没有为类定义一个具体的构造函数，编译器会为你提供一个默认的无参构造函数,但是，一旦你为类定义了任何构造函数（无论是否带参数），编译器就不再提供默认的无参构造函数.***

+ ---



## 调用方式

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
		Person() {
			cout << "Person对象被成功创建！" << endl;
		}
		Person(int a_ge) {
			cout << "Person对象被成功创建！,该对象今年" << a_ge << "岁了！" << endl;
		}
		Person(string na_me, int a_ge) {
			name = na_me;
			age = a_ge;
			cout << "对象的姓名：" << name << ", 今年" << age << "岁了。" << endl;
		}
};
int main() {
	//显式调用
	Person xiaoming = Person();
	//<-->Person xiaoming;
	Person xiaoli = Person(18);
	//<--->Person  xiaoli(18);
	Person xiaozi = Person("xiaozi", 21);
	//<--->Person xiaozi("xiaozi",21)

	//隐式调用
	Person xiaolv = {};
	Person xiaogao = {18};
	Person xiaoshi = {"runrun", 20};

	//实例化：在堆上创建对象
	Person *zhao = new Person("shage", 21);

	return 0;
}
```

## `explicit`关键字的使用

+ `explicit`关键字用来修饰构造函数，放在构造函数名称之前，表示该种构造函数不支持隐式调用

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
		Person() {
			cout << "Person对象被成功创建！" << endl;
		}
		explicit Person(int a_ge) {
			cout << "Person对象被成功创建！,该对象今年" << a_ge << "岁了！" << endl;
		}
		Person(string na_me, int a_ge) {
			name = na_me;
			age = a_ge;
			cout << "对象的姓名：" << name << ", 今年" << age << "岁了。" << endl;
		}
};
int main() {
	Person xiaoshi;
	Person xiaogao = Person(22);
	Person zhao = {21};
	//[Error] converting to 'Person' from initializer list would use explicit constructor 'Person::Person(int)'
	return 0;
}
```

+ 使用该关键字主要目的还是防止出现赋值错误之类的失误，提高代码的安全性

# 构造函数初始化列表

构造函数初始化列表顾名思义就是在类中创建新对象时，对对象的属性进行初始化赋值

```cpp
//1.不太好的写法
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
		int height;
/***错误的写法，这时候编译器也识别不出来
	Person(string name, int age, int height){
		name = name;
		age = age;
		height = height;
	}
***/

/***不太好的写法，个人感觉太别扭
	Person(string na_me, int a_ge, int hei_ght){
		name = na_me;
		age = a_ge;
		height = hei_ght;
	}
***/

//正确的写法
class Person {
	public:
		string name;
		int age;
		int height;
  	
		Person(string name, int age, int height): name(name), age(age), height(height) {};
};
  
};
int main() {
	Person xiaoming = Person("xiaoming", 18, 80);
	cout<<xiaoming.name<<" "<<xiaoming.age<<" "<<xiaoming.height<<endl;
	return 0;
}
```

考虑到函数重载，你可以在属性的基础上写出不同的构造函数

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
		int height;
		Person(string name, int age): name(name), age(age){
			cout<<"该女士不方便透露体重信息"<<endl;
			};
		Person(string name, int age, int height): name(name), age(age), height(height) {};
};
int main() {
	Person xiaoming = Person("xiaoming", 18, 80);
	cout << xiaoming.name << " " << xiaoming.age << " " << xiaoming.height << endl;
	Person xiaozi = Person("xiaozi",18);
	cout << xiaozi.name << " " << xiaozi.age<<endl;
	return 0;
}
```

# 拷贝构造函数

cpp中的构造函数：

+ 按照参数：无参与有参构造函数
+ 按照构造： 普通构造与拷贝构造

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		string name;
		int age;
		int height;
		Person(string name, int age, int height): name(name), age(age), height(height) {};
};
int main() {
	Person xiaoming = Person("xiaoming", 18, 80);
	Person zhao = xiaoming;
	cout<<&xiaoming<<endl;
	cout<<&zhao<<endl;
	return 0;
}
```

显然通过拷贝构造函数，两者的地址肯定是不同的，这就好比

```cpp
int x = 10;
int y = x;
```

两者仅仅是值相同。

+ 如果没有提供拷贝构造函数，编译器将生成一个默认的拷贝构造函数。

```cpp
#include <iostream>

class Person {
public:
    std::string name;
    int age;

    // 拷贝构造函数
    Person(const Person& other) : name(other.name), age(other.age) {
        std::cout << "拷贝构造函数被调用！" << std::endl;
    }

    // 构造函数
    Person(std::string n, int a) : name(n), age(a) {}
};

int main() {
    Person alice("Alice", 25);

    // 使用拷贝构造函数
    Person bob = alice;

    return 0;
}

```

# 析构函数

析构函数是 C++ 中一个重要的特性，用于在对象被销毁时执行必要的清理操作。

+ 析构函数是类中的一个特殊成员函数，其名称与类名相同，前面加上波浪号 `~`。析构函数没有参数，也没有返回值。

析构函数会在以下情况下自动被调用：

- 当对象离开其作用域时（出栈）。
- 当一个对象被删除（使用 `delete` 运算符）时。
- 当一个对象是一个局部对象，且程序执行离开其作用域时。

**总的来说就对象死的时候，析构函数就会被触发**

```cpp
#include <iostream>

class Resource {
public:
    Resource() {
        std::cout << "Resource被创建！" << std::endl;
    }

    ~Resource() {
        std::cout << "Resource被销毁！" << std::endl;
    }
};

class MyClass {
public:
    Resource* ptrResource;

    MyClass() : ptrResource(new Resource()) {
        std::cout << "MyClass被创建！" << std::endl;
    }

    ~MyClass() {
        delete ptrResource;  // 释放动态分配的资源
        std::cout << "MyClass被销毁！" << std::endl;
    }
};

int main() {
    MyClass obj;
    return 0;
}
```

# 浅拷贝与深拷贝

- **浅拷贝（Shallow Copy）：** 浅拷贝只是简单地复制对象的成员变量的值，包括指针成员的地址值。这意味着原对象和副本对象共享相同的内存资源。
- **深拷贝（Deep Copy）：** 深拷贝会复制对象的所有成员，包括指针成员指向的内存。这样，原对象和副本对象拥有各自独立的内存资源，互不影响。

## 浅拷贝

浅拷贝是默认的拷贝方式，当你没有自定义拷贝构造函数和赋值运算符时，C++ 编译器会提供一个默认的浅拷贝。它只是逐个复制成员变量的值，包括指针成员的地址。

### 示例

```cpp
#include <iostream>

class ShallowCopy {
public:
    int* data;

    ShallowCopy(int value) {
        data = new int(value);
    }

    // 默认拷贝构造函数（浅拷贝）
    // 默认赋值运算符也是浅拷贝
};

int main() {
    ShallowCopy original(42);
    ShallowCopy copy = original;  // 浅拷贝

    std::cout << "Original: " << *(original.data) << std::endl;
    std::cout << "Copy: " << *(copy.data) << std::endl;

    // 修改拷贝后的对象
    *(copy.data) = 99;

    std::cout << "After modification:" << std::endl;
    std::cout << "Original: " << *(original.data) << std::endl;
    std::cout << "Copy: " << *(copy.data) << std::endl;

    // 内存泄漏：两个对象共享相同的 data 指针，delete 一次后，另一方指针成为悬空指针
    delete original.data;

    return 0;
}
```

上述代码演示了浅拷贝的行为。由于两个对象共享相同的指针，修改一个对象的值会影响到另一个对象。同时，删除一个对象的指针可能导致另一个对象的指针成为悬空指针，引发内存泄漏。

##  深拷贝

深拷贝需要手动实现拷贝构造函数和赋值运算符，确保在复制对象时，分配新的内存来存储成员变量的值。这样，原对象和副本对象拥有独立的内存资源，修改一个不会影响另一个。

###  示例

```cpp
#include <iostream>

class DeepCopy {
public:
    int* data;

    DeepCopy(int value) {
        data = new int(value);
    }
  
	  DeepCopy(const DeepCopy &p){
		    data = new int;
		   *data = *(p.data);
	}
    
};

int main() {
    DeepCopy original(42);
    DeepCopy copy = original;  // 深拷贝

    std::cout << "Original: " << *(original.data) << std::endl;
    std::cout << "Copy: " << *(copy.data) << std::endl;

    // 修改拷贝后的对象
    *(copy.data) = 99;

    std::cout << "After modification:" << std::endl;
    std::cout << "Original: " << *(original.data) << std::endl;
    std::cout << "Copy: " << *(copy.data) << std::endl;

    // 内存安全：两个对象data 指针都不相同
    delete original.data;
    delete copy.data;

    return 0;
}
```

从代码示例中我们可以看出来，深拷贝本质上就是再开辟一块空间存储值，浅拷贝就是直接把空间地址全拷贝了。

## `this`指针

+ `this`指针在C++中用来指向当前对象。

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		Person() {}
		Person(int a): age(a) {}

		//这里使用this指针来访问age属性，这种写法是默认的，并且this是可以省略不写的
		//那么所谓的当前对象到底是谁呢？
		//最通俗的理解就是那个对象调用，this指针就指向谁
		int getAge() {
			return this->age;
		}
		void printAddress() {
			cout << "this address: " << this << endl;
		}

	private:
		int age;
};

int main() {

	Person xiaoming(42);
	cout << xiaoming.getAge() << endl; //42
	xiaoming.printAddress(); //0x...
	return 0;
}
```

在一个类中，涉及到非静态成员的属性访问时通常使用`this`指针来访问。在**大多数情况下，你不需要显式地使用 `this` 指针，因为它在成员函数内部被隐式使用。**

+ 不能省略`this`指针的情况：

1. **成员函数中存在与成员属性同名的局部变量，需要用`this`指针明确是成员变量**

```cpp
#include <iostream>
using namespace std;
class Person {
	public:
		Person() {}
		Person(int a): age(a) {}

		int getAge() {
			return this->age;
		}
		 void setAge(int age){
		 	this->age = age; 
		 	//不可写作：age = age
		 }
	private:
		int age;
};

int main() {

	Person xiaoming(42);
	cout << xiaoming.getAge() << endl; //42
	
	xiaoming.setAge(88);
	cout << xiaoming.getAge() << endl; //88
	
	return 0;
}
```

2. **在运算符重载中：** 在某些运算符重载情况下，需要使用`this`指针以确保正确引用对象的成员。例如：

```cpp
#include <iostream>
using namespace std;
class Complex {
	public:
		Complex() {}
		Complex(double real, double img): real(real), img(img) {}

		void printComplex() const {
			cout << "real: " << this->real << " " << "img: " << this->img << endl;
		}

		Complex operator+(const Complex& other) const {
			Complex result;
			result.real = this->real + other.real;
			result.img  = this->img + other.img;
			return result;

		}

	private:
		double real;
		double img;
};


int main() {

	Complex c1(2.3, 6.6);
	Complex c2(3.6, 5.3);
	Complex sum = c1 + c2;
	sum.printComplex(); //real: 5.9 img: 11.9


	return 0;
}
```

总体而言，大多数情况下，`this`指针是隐式的，不需要显式引用。但在上述情况下，显式使用`this`指针有助于代码的清晰性和可读性。

## 返回对象的函数

```cpp
#include <iostream>
using namespace std;
class Mynumber {
	public:
		Mynumber(): value(0) {}
		Mynumber(int n): value(n) {}

		int getValue() const {
			return this->value;
		}

		//设计一个函数，累加一个数字，返回对象本身
		Mynumber &add(int n) {
			this->value += n;
			return *this;
		}

	private:
		int value;
};

int main() {

	Mynumber n(10);
	n.add(8).add(2); //链式编程
	cout << n.getValue() << endl;

	return 0;
}
```

当一个函数返回一个对象时，**C++ 中的规则是函数可以返回对象的实例，也可以返回对象的引用或指针。这样的函数通常被称为返回对象的函数。**

### 返回对象的实例：

```cpp
#include <iostream>

class MyObject {
public:
    MyObject(int val) : value(val) {}

    // 返回对象的函数
    static MyObject createObject(int val) {
        MyObject obj(val);
        return obj;
    }

    void display() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    MyObject newObj = MyObject::createObject(42);
    newObj.display();

    return 0;
}
```

在上述例子中，`createObject` 函数返回一个 `MyObject` 类的实例，这个实例被复制到 `newObj` 中。

### 返回对象的引用：

```cpp
#include <iostream>

class MyObject {
public:
    MyObject(int val) : value(val) {}

    // 返回对象的函数
    static MyObject& createObject(int val) {
        static MyObject obj(val);  // 使用静态变量，确保生命周期足够长
        return obj;
    }

    void display() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    MyObject& newObj = MyObject::createObject(42);
    newObj.display();

    return 0;
}
```

在这个例子中，`createObject` 函数返回一个 `MyObject` 类的引用，确保返回的引用指向一个在函数外部定义的对象。

### 返回对象的指针：

```cpp
#include <iostream>

class MyObject {
public:
    MyObject(int val) : value(val) {}

    // 返回对象的函数
    static MyObject* createObject(int val) {
        MyObject* obj = new MyObject(val);  // 使用动态内存分配
        return obj;
    }

    void display() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    MyObject* newObj = MyObject::createObject(42);
    newObj->display();

    delete newObj;  // 记得释放动态分配的内存

    return 0;
}
```

在这个例子中，`createObject` 函数返回一个 `MyObject` 类的指针，使用了动态内存分配。需要记住，当使用 `new` 关键字分配内存时，最后要使用 `delete` 来释放这块内存。在现代 C++ 中，最好使用智能指针（例如 `std::unique_ptr` 或 `std::shared_ptr`）来管理动态内存。

## 空指针访问成员函数

在C++中，尝试使用空指针（即指向空地址的指针）来调用成员函数通常会导致未定义行为。这是因为成员函数的实现依赖于 `this` 指针，而空指针没有有效的对象实例。

例如，考虑以下代码：

```cpp
#include <iostream>

class MyClass {
public:
    void myFunction() {
        std::cout << "Hello from myFunction!" << std::endl;
    }
};

int main() {
    MyClass* ptr = nullptr;

    // 尝试使用空指针调用成员函数
    ptr->myFunction();  // 这会导致未定义行为

    return 0;
}
```

在上面的例子中，`ptr` 是一个空指针，尝试通过它调用 `myFunction` 函数将导致未定义行为，因为 `this` 指针在这种情况下是无效的。

为了避免这种问题，应该在调用成员函数之前检查指针是否为空。例如：

```cpp
#include <iostream>
class MyClass {
	public:
		void myFunction() {
			if (this == nullptr) { // 检查指针是否为空
				std::cout << "这是一个空指针！" << std::endl;
				return;
			}
			std::cout << "Hello from myFunction!" << std::endl;
		}
};

int main() {
	MyClass* ptr = nullptr;

	ptr->myFunction();

	return 0;
}
```

在实际编程中，建议在使用指针之前总是进行空指针检查，以确保不会访问无效的内存地址。

## 常函数

在C++中，**常函数（const member function）是指在类的成员函数声明和定义中使用 `const` 关键字修饰的函数。常函数承诺不修改调用它的对象的成员变量。**这对于确保对象在函数调用期间不被修改很有用，也允许在常对象上调用这些函数。

**常成员函数可以用于常对象，也可以用于非常对象。对于非常对象，它们可以调用常成员函数和普通成员函数。**

**常函数的另一个常见用途是在常对象上提供只读访问。通过使用常成员函数，你可以确保在常对象上调用函数时不会意外地修改对象的状态。**

```cpp
//const修饰类成员函数，表示这个函数是一个“常函数”
//			-使用关键词const修饰
//			-常函数中，不允许修改对象的属性
//			-常函数中，不允许调用普通成员函数

#include <iostream>
using namespace std;

class Person {
	public:
		Person(): name(""), age(0), score(0) {}
		Person(string name, int age, int score): name(name), age(age), score(score) {}

		void fixPerson(string newName, int newAge, int newScore) const {
			this->display();
			this->name = newName;
			this->age = newAge;
			this->score = newScore;				//error！！！
		}

		void display() {
			cout << "name = " << name << endl;
			cout << "age = " << age << endl;
			cout << "score = " << score << endl;
		}

	private:
		string name;
		int age;
		int score;
};

int main() {

	Person xiaoming("xiaobai", 18, 99);
	xiaoming.display();
	xiaoming.fixPerson("xiaowang", 20, 98);
	xiaoming.display();
	
	return 0;
}
```

- **常函数不能对普通成员变量（除mutable修饰外）进行写操作**

- **常函数可以被普通对象或者常对象调用**



## 常对象

+ **创建对象的时候，使用关键字`const`修饰的对象，就是常对象**
+ **常对象属性的值`read_only`**
+ **常对象仅可调用常成员函数，不可调用普通成员函数**

```cpp
#include <iostream>
using namespace std;

class Person {
	public:
		Person(): name(""), age(0), score(0) {}
		Person(string name, int age, int score): name(name), age(age), score(score) {}

		void fixPerson(string newName, int newAge, int newScore)  {
			this->name = newName;
			this->age = newAge;
			this->score = newScore;
		}

		void display() {
			cout << "name = " << name << endl;
			cout << "age = " << age << endl;
			cout << "score = " << score << endl;
		}

		void showConst() const {
			cout << "this is a const member function!" << endl;
			cout << this->age << " " << this->name << " " << this->score << endl;
		}
	private:
		string name;
		int age;
		int score;
};

int main() {

	const Person xiaoming("xiaoming", 18, 99);
   
	xiaoming.display(); //[Error] passing 'const Person' as 'this' argument discards qualifiers [-fpermissive]
   
	xiaoming.fixPerson("xiaobai", 21, 93); //[Error] passing 'const Person' as 'this' argument discards qualifiers [-fpermissive]
   
	xiaoming.showConst();  
//	this is a const member function!
//	18 xiaoming 99

	return 0;
}
```



## `mutable` 关键字

在C++中，`mutable` 是一个关键字，用于修饰类的成员变量。当一个成员变量被声明为 `mutable` 时，即使在常成员函数中，仍然允许修改这个成员变量的值，对于一个常对象，该对象的用mutable修饰的属性仍可修改。

通常，常成员函数承诺不修改对象的状态，这意味着它们不能修改成员变量的值。然而，有时候可能希望在常成员函数中修改某些状态，例如在缓存数据的情况下。这时候使用 `mutable` 关键字。

```cpp
#include <iostream>

class MyClass {
public:
   	MyClass() {}
   	MyClass(int value): value(value) {}
   	
    // 常成员函数的定义
    void display() const {
        std::cout << "Value: " << this->value << std::endl;
    }

    // 修改成员变量的值，即使在常成员函数中
    void setValue(int newValue) const {
        // 允许在常成员函数中修改被声明为 mutable 的成员变量
        value = newValue;
    }

private:
    mutable int value;  // 使用 mutable 关键字
};

int main() {
    MyClass obj(18);
    obj.display();
    
    
    obj.setValue(42);   // 在常对象上调用常成员函数，修改了 mutable 成员变量的值
    obj.display();       // 输出: Value: 42

    const MyClass obj2(34); //创建一个常对象
	 obj2.setValue(100);	//修改常对象的属性值
	 obj2.display();
   
    return 0;
}
```



## 友元

**在C++中，友元（friend）是一种机制，允许一个类或函数访问另一个类的私有成员。通过友元关系，一个类可以授权其他类或函数访问它的私有成员，从而增加了灵活性和封装性的一些破坏。**

有两种类型的友元：

1. **类友元**（Friend Class）：一个类可以将另一个类声明为友元，使得被声明为友元的类成员函数及属性可以访问该类的私有成员。**友元关系是双向的，如果类A将类B声明为友元，那么类B也可以访问类A的私有成员。**

   ```cpp
   #include <iostream>
   #include <string>
   
   class Room;  // 前置声明
   
   class Home {
   private:
       std::string bedRoom = "这里是卧室！";
   
   public:
       std::string livingRoom = "这里是客厅！";
   
       // 将Room类的成员函数声明为友元函数
       friend void Room::printRoomInfo(Home& home);
   };
   
   class Room {
   public:
       void printRoomInfo(Home& home) {
           // 在成员函数中访问Home类的私有成员
           std::cout << "客厅: " << home.livingRoom << std::endl;
           std::cout << "卧室: " << home.bedRoom << std::endl;
       }
   };
   
   int main() {
       Home myHome;
       Room myRoom;
   
       // 调用Room类的成员函数，该函数是Home类的友元函数
       myRoom.printRoomInfo(myHome);
   
       return 0;
   }
   
   ```

2. **函数友元**（Friend Function）：**一个函数可以被声明为类的友元，使得该函数可以访问该类的私有成员。**

   ```cpp
   #include <iostream>
   using namespace std;
   
   class Home {
   	private:
   		string bedRoom = "这里是卧室！";
   
   	public:
   		string livingRoom = "这里是客厅！";
   		friend void printRoom(Home *home);      //友元函数的定义应该在类的内部
   };
   
   void printRoom(Home *home) {       //在类的外部对其进行声明
   	//访问public
   	cout << home->livingRoom << endl;
   	//访问private
   	cout << home->bedRoom << endl;
   
   }
   int main() {
   
   	Home *home = new Home();
   	printRoom(home);
   
   	return 0;
   }
   ```

友元关系破坏了类的封装性，因此应该谨慎使用

## 运算符重载

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以**适应不同的数据类型。**

运算符重载(operator overloading)只是一种”语法上的方便”，**本质上是一种函数调用。**

**在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。**

**语法：**
	定义重载的运算符就像定义函数，只是该函数的名字是`operator@`,这里的`@`代表了被重载的运算符。

​    函数的参数中参数个数取决于两个因素：

+ 运算符是一元(一个参数)

+ 二元(两个参数)

   

在C++中，运算符重载可以通过全局函数或成员函数来实现。下面是一些关键概念：

1. **全局函数：** 运算符重载可以通过全局函数来实现。对于二元运算符，这个函数有两个参数，其中一个是运算符左侧的操作数，另一个是右侧的操作数。对于一元运算符，函数只有一个参数。

   ```cpp
   // 全局函数重载二元运算符
   ReturnType operator+(const MyClass& left, const MyClass& right) {
       // 实现运算符的功能
   }

   // 全局函数重载一元运算符
   ReturnType operator-(const MyClass& obj) {
       // 实现运算符的功能
   }
   ```

2. **成员函数：** 对于二元运算符，可以通过类的成员函数来实现，其中类的对象用作左侧的操作数，右侧的操作数作为函数的参数。对于一元运算符，成员函数没有参数。

   ```cpp
   class MyClass {
   public:
       // 成员函数重载二元运算符
       ReturnType operator+(const MyClass& right) const {
           // 实现运算符的功能
       }
   
       // 成员函数重载一元运算符
       ReturnType operator-() const {
           // 实现运算符的功能
       }
   };
   ```

![image-20240221171810034](C:/Users/Exiler/AppData/Roaming/Typora/typora-user-images/image-20240221171810034.png)

### 运算符重载`+`、`-`

```cpp
class Point {
public:
    // 定义属性
    int x;
    int y;

    // 定义构造函数，用来初始化属性
    Point(): x(0), y(0) {}
    Point(int x, int y): x(x), y(y) {}

    // 在类内实现的运算符重载
    Point operator+(const Point& p) const {
        return {x + p.x, y + p.y};
    }
};

// 全局函数实现运算符重载
Point operator-(const Point& p1, const Point& p2) {
    return {p1.x - p2.x, p1.y - p2.y};
}

int main() {

    Point p1(10, 20);
    Point p2(15, 25);

    Point res = p1 + p2;
    cout << "res.x = " << res.x << ", res.y = " << res.y << endl;

    Point res2 = p1 - p2;
    cout << "res2.x = " << res2.x << ", res2.y = " << res2.y << endl;

    return 0;
}
```



### 运算符重载`++`、`--`

+ 前置运算符先运算再取值，返回原对象的引用
+ 后置运算符先取值后运算，返回原对象运算前的一个副本

```cpp
class Point {
public:
    // 定义属性
    int x;
    int y;

    // 定义构造函数，用来初始化属性
    Point(): x(0), y(0) {}
    Point(int x, int y): x(x), y(y) {}

    // 前置递增运算符重载
    Pointer& operator++() {
        // 递增x和y
        ++x;
        ++y;
        // 返回递增后的对象的引用
        return *this;
    }

    // 后置递增运算符重载
    Pointer operator++(int) {
        // 保存递增前的对象的副本
        Pointer temp = *this;
        // 递增x和y
        ++x;
        ++y;
        // 返回递增前的对象的副本
        return temp;
    }
};

Point operator--(Point& point) {
    point.x--;
    point.y--;
    return point;
}

Point operator--(Point& point, int) {
    Point tmp = point;
    point.x--;
    point.y--;
    return tmp;
}

int main() {

    Point p1(10, 20);
    Point p2(15, 25);

    Point res1 = ++p1;
    cout << "res1.x = " << res1.x << ", res1.y = " << res1.y << endl;
    cout << "p1.x = " << p1.x << ", p1.y = " << p1.y << endl;

    Point res2 = p2++;
    cout << "res2.x = " << res2.x << ", res2.y = " << res2.y << endl;
    cout << "p2.x = " << p2.x << ", p2.y = " << p2.y << endl;

    return 0;
}
```



### 运算符重载`<<`、`>>`

```cpp
#include <iostream>

class Point {
public:
    int x;
    int y;

    Point() : x(0), y(0) {}
    Point(int x, int y) : x(x), y(y) {}


    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const Point& point) {
        os << "x: " << point.x << ", y: " << point.y;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, Point& point) {
        std::cout << "Enter x: ";
        is >> point.x;
        std::cout << "Enter y: ";
        is >> point.y;
        return is;
    }
};

int main() {
    Point p1;
    std::cout << "Enter data for p1:" << std::endl;
    std::cin >> p1;

    std::cout << "p1: " << p1 << std::endl;

    return 0;
}

```

### 运算符重载`=`

```cpp
#include <iostream>

class Point {
public:
    int x;
    int y;

    Point() : x(0), y(0) {}
    Point(int x, int y) : x(x), y(y) {}

    // 赋值运算符重载
    Point& operator=(const Point& other) {
        if (this != &other) {  //防止自我赋值
            x = other.x;
            y = other.y;
        }
        return *this;
    }
       
   // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const Point& point) {
        os << "x: " << point.x << ", y: " << point.y;
        return os;
    }
   
};

int main() {
    Point p1(10, 20);
    Point p2;

    // 使用赋值运算符进行赋值
    p2 = p1;

    std::cout << "After assignment:" << std::endl;
    std::cout << "p1: " << p1 << std::endl;
    std::cout << "p2: " << p2 << std::endl;

    return 0;
}
```

```cpp
#include <iostream>
using namespace std;

class Person {
	public:
		int age;
		int score;
		int* p;

		Person(): age(0), score(0), p(nullptr) {}

		Person(const Person& person) {
			cout << "拷贝构造函数执行了" << endl;
			age = person.age;
			score = person.score;
			p = new int(*person.p);
		}

		// 重载赋值运算符
		Person& operator=(const Person& person) {
			cout << "重载赋值运算符执行了" << endl;
			age = person.age;
			score = person.score;
			p = new int(*person.p);
			return *this;
		}

		~Person() {
			cout << "析构函数执行了" << endl;
			if (p == nullptr) {
				delete p;
				p = nullptr;
			}
		}
};

int main() {

	// 创建一个对象
	Person p1;
	p1.age = 18;
	p1.score = 99;
	p1.p = new int(100);

	// 在这里，虽然是等号运算符，但是p2对象还没有完成空间开辟、实例化，那么在这里会调用拷贝构造函数，而非重载的等号运算符
	Person p2 = p1;

	// 修改p2的属性值
	p2.age = 20;
	p2.score = 100;
	p2.p = new int(200);

	// 这里的p1已经开辟空间了，这里就会触发重载的等号运算符
	p1 = p2;
	cout << p1.age << ", " << p1.score << ", " << p1.p << " =>" << *p1.p << endl;
	cout << p2.age << ", " << p2.score << ", " << p2.p << " =>" << *p2.p << endl;


	return 0;
}
```



## 封装

封装是面向对象编程（OOP）的一个重要概念，它指的是**将类的数据成员和成员函数捆绑在一起，形成一个类的实体，并且对外部隐藏实现的细节。通过封装，类的内部实现细节被隐藏，只有通过类的公共接口（公共成员函数）才能与类进行交互。**

在C++中，封装主要通过访问控制关键字来实现，其中包括`public`、`private`和`protected`。这些关键字用于控制类的成员在类外部的可见性和访问权限。

下面是一个简单的例子来说明C++中的封装：

```cpp
#include <iostream>

class Person {
private:
    // 私有数据成员，外部无法直接访问
    std::string name;
    int age;

public:
    // 公有成员函数，提供对私有数据的访问
    void setName(const std::string& newName) {
        name = newName;
    }

    void setAge(int newAge) {
        if (newAge >= 0) {
            age = newAge;
        } else {
            std::cout << "Age cannot be negative." << std::endl;
        }
    }

    // 公有成员函数，提供对私有数据的访问
    std::string getName() const {
        return name;
    }

    int getAge() const {
        return age;
    }

    // 公有成员函数
    void displayInfo() const {
        std::cout << "Name: " << name << ", Age: " << age << std::endl;
    }
};

int main() {
    // 创建Person类的对象
    Person person;

    // 通过公有成员函数设置私有数据
    person.setName("John");
    person.setAge(25);

    // 通过公有成员函数获取私有数据并显示信息
    std::cout << "Person's name: " << person.getName() << std::endl;
    std::cout << "Person's age: " << person.getAge() << std::endl;

    // 通过公有成员函数显示信息
    person.displayInfo();

    return 0;
}
```

在这个例子中，`Person` 类的私有数据成员（`name`和`age`）被封装在类的内部，通过公有成员函数提供对这些私有数据的访问。外部代码只能通过公有接口来与类进行交互，而不能直接访问私有数据。这种封装的方式有助于隐藏类的实现细节，提高代码的可维护性和安全性。

## 继承

继承，是类与类之间的特征和行为的一种赠予或获取。**一个类可以将自己的属性和方法赠予其他的类，一个类也可以从其他的类中获取他们的属性和方法。**

两个类之间的继承，必须满足 **is a** 的关系。

两个类之间，A类将属性和特征赠予B类。此时A类被称为是**父类**，B类被称为是**子类**，两者之间的关系是**子类继承自父类**

![image-20220906092001239](../../../typora_scn/类.png)

#### 2.8.2. 继承的语法

在C++中，**在定义类的时候，类名后面使用冒号来定义父类。**

-   **类中的所有成员都可以继承给子类，但是私有的成员，由于访问权限的限制，子类无法访问。**
-   **一个类在继承了其他类之后，也可以被其他类继承。**
-   **使用继承，可以简化代码、提高代码的复用性、提高代码的拓展性，最重要的是让类与类之间产生了继承关系，是多态的前提。**

```c++
class Animal {
public:
    int age;
}
class Dog: public Animal {
    void test() {
        cout << age << endl;
    }
}
int main() {
    Dog dog;
    dog.test();
    
    return 0;
}
```



#### 2.8.3. 继承的三种方式

在C++中，继承有三种方式，分别是：公共继承、保护继承和私有继承。其实只是一个访问权限的问题。

-   **公共继承：**继承到父类中的属性，保留原本的访问权限（私有除外）
-   **保护继承：** **继承到父类中的属性，超过protected权限的部分将降为protected权限（私有除外）**
-   **私有继承：**继承到父类中的属性，访问权限都为private权限（私有除外）

**C++中默认使用的是私有继承！**



##### 2.8.3.1. 公共继承

```c++
// 定义类，分别定义三种访问权限的属性
class BaseClass {
public:
	int publicField;
protected:
    int protectedField;
private:
    int privateField;
}

// 定义派生类，公共继承
// 继承到的 publicField，还是public权限
// 继承到的 protectedField，还是protected权限
// privateField是私有权限的，无法继承给自类

class SubClass: public BaseClass {
    void test() {
        cout << publicField << endl;
        cout << protectedField << endl;
    }
}

int main() {
    SubClass sc;
    cout << sc.publicField << endl;		// 在类外依然可以访问
    // cout << sc.protectedField << endl;	// 类外不能访问，因为这是保护权限
}
```

##### 2.8.3.2. 保护继承

```c++
// 定义类，分别定义三种访问权限的属性
class BaseClass {
public:
	int publicField;
protected:
    int protectedField;
private:
    int privateField;
}

// 定义派生类，保护继承
// 继承到的 publicField，原来是public权限，现在是protected权限

// 继承到的 protectedField，还是protected权限

// privateField是私有权限的，无法继承给自类

class SubClass: protected BaseClass {
    void test() {
        cout << publicField << endl;
        cout << protectedField << endl;
    }
}

int main() {
    SubClass sc;
    // cout << sc.publicField << endl;		// 类外不能访问，因为这是保护权限
    // cout << sc.protectedField << endl;	// 类外不能访问，因为这是保护权限
}
```

##### 2.8.3.3. 私有继承

```c++
// 定义类，分别定义三种访问权限的属性
class BaseClass {
public:
	int publicField;
protected:
    int protectedField;
private:
    int privateField;
}

// 定义派生类，私有继承
// 继承到的 publicField，是私有权限
// 继承到的 protectedField，是私有权限
// privateField是私有权限的，无法继承给自类

class SubClass: public BaseClass {
    void test() {
        cout << publicField << endl;
        cout << protectedField << endl;
    }
}

int main() {
    SubClass sc;
    // cout << sc.publicField << endl;		// 类外不能访问，因为这里是私有权限
    // cout << sc.protectedField << endl;	// 类外不能访问，因为这里是私有权限
}
```

```cpp
#include <iostream>

// 基类
class Animal {
public:
    void eat() {
        std::cout << "Animal is eating." << std::endl;
    }

    void sleep() {
        std::cout << "Animal is sleeping." << std::endl;
    }
};

// 公有继承
class Dog : public Animal {
public:
    void bark() {
        std::cout << "Dog is barking." << std::endl;
    }
};

// 私有继承
class Cat : private Animal {
public:
    void meow() {
        std::cout << "Cat is meowing." << std::endl;
    }
};

// 保护继承
class Tiger : protected Animal {
public:
    void roar() {
        std::cout << "Tiger is roaring." << std::endl;
    }
};

int main() {
    // 公有继承示例
    Dog myDog;
    myDog.eat();
    myDog.sleep();
    myDog.bark();

    // 私有继承示例
    Cat myCat;
    // myCat.eat(); // Error: 'Animal' is a private member of 'Cat'
    // myCat.sleep(); // Error: 'Animal' is a private member of 'Cat'
    myCat.meow();

    // 保护继承示例
    Tiger myTiger;
    // myTiger.eat(); // Error: 'Animal' is a protected member of 'Tiger'
    // myTiger.sleep(); // Error: 'Animal' is a protected member of 'Tiger'
    myTiger.roar();

    return 0;
}
```

---





+ **子类对象在创建的时候，需要先调用父类中的构造函数，用来初始化父类部分。因此，子类对象创建的时候，先调用父类的构造函数，再调用子类自己的构造函数。**

+ **而析构函数的调用正好相反，先调用子类的析构函数，再调用父类的析构函数。**

```c++
#include <iostream>
using namespace std;

class Animal {
	public:
		int age;

		Animal() {
			age = 0;
			cout << "父类中的无参构造函数调用了" << endl;
		}

		explicit Animal(int age): age(age) {
			cout << "父类中的有参构造函数调用了" << endl;
		}

		~Animal() {
			cout << "父类中的析构函数调用了" << endl;
		}
};

class Dog: public Animal {
	public:
		explicit Dog() {
			cout << "子类中的无参构造函数被调用了" << endl;
		}

		~Dog() {
			cout << "子类中的析构函数被调用了" << endl;
		}
};

int main() {

	Dog dog;

//	父类中的无参构造函数调用了
//	子类中的无参构造函数被调用了
//	子类中的析构函数被调用了
//	父类中的析构函数调用了

	return 0;
}
```



> 子类对象在创建的时候，需要先调用父类中的构造函数来构造父类部分。这里默认是调用父类中的无参构造函数。那么问题来了：如果父类中没有无参构造函数，或者父类中的无参构造函数是私有的，怎么办？

+ **如果父类中没有无参构造函数，或者父类中的无参构造函数是私有的，你需要在子类的构造函数中显式调用父类的有参构造函数，并提供适当的参数。在这种情况下，子类的构造函数中必须负责传递参数给父类的有参构造函数。**

```c++
#include <iostream>
using namespace std;

class Animal {
public:
    int age;

    explicit Animal(int age): age(age) {
        cout << "父类中的有参构造函数调用了" << endl;
    }

    ~Animal() {
        cout << "父类中的析构函数调用了" << endl;
    }
};

class Dog: public Animal {
public:
    explicit Dog(int dogAge): Animal(dogAge) {
        cout << "子类中的有参构造函数被调用了" << endl;
    }

    ~Dog() {
        cout << "子类中的析构函数被调用了" << endl;
    }
};

int main() {
    Dog dog(3);
    return 0;
}

```

父类 `Animal` 没有无参构造函数，而是有一个接受年龄参数的有参构造函数。子类 `Dog` 的构造函数在初始化列表中调用了父类的有参构造函数，通过传递适当的参数来确保正确构造。



#### 2.8.5. 父类子类成员同名的情况

**如果父类和子类中出现了同名字的成员（属性、函数），子类会将从父类继承到的成员隐藏起来。此时使用子类对象来访问的时候，默认访问的是子类中的成员。如果想要访问父类中的成员，需要手动指定作用域。**

```c++
#include <iostream>
using namespace std;

class Animal {
	public:
		int age = 10;

		void showAge() const {
			cout << "父类中的函数showAge被调用，age = " << age << endl;
		}

};

class Dog: public Animal {
	public:
		int age;

		void showAge() const {
			cout << "子类中的函数showAge被调用，age = " << age << endl;
		}
};

int main() {

	Dog dog;
	dog.age = 2;

	dog.showAge();          // 默认调用的是子类中的函数
	dog.Animal::showAge();  // 如果想要调用父类中的函数，需要显式调用

	cout << dog.age << endl;            // 默认访问自类中的属性age
	cout << dog.Animal::age << endl;    // 如果想要调用父类中的属性age，需要显式调用

	return 0;
}
/*
子类中的函数showAge被调用，age = 2
父类中的函数showAge被调用，age = 10
2
10
*/
```

#### 2.8.6. 多继承

+ 一个派生类可以继承多个基类

##### 2.8.6.1. 多继承语法

> 我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。

但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。

多继承会带来一些二义性的问题，如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？

解决方法就是**显示指定调用那个基类的版本。**

```c++
#include <iostream>
using namespace std;

class Base1 {
	public:
		void func1() {
			cout << "Base1::func1" << endl;
		}
};
class Base2 {
	public:
		void func1() {
			cout << "Base2::func1" << endl;
		}
		void func2() {
			cout << "Base2::func2" << endl;
		}
};

// 派生类继承Base1、Base2
class Derived : public Base1, public Base2 {};
int main() {

	Derived derived;
// func1是从Base1继承来的还是从Base2继承来的？
// derived.func1(); //[Error] request for member 'func1' is ambiguous 有歧义！
	derived.func2();

	//解决歧义:显示指定调用那个基类的func1
	derived.Base1::func1();
	derived.Base2::func1();

	return 0;
}
```

##### 2.8.6.2. 菱形继承

**两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石型继承。**

<img src="../../../typora_scn/菱形继承.png" alt="image-20220906111216636" style="zoom:30%;" />

这种继承所带来的问题：

-   羊继承了动物的属性，骆驼同样继承了动物的数据和函数，当草泥马调用函数或者数据时，就会产生二义性。

-   草泥马继承自动物的函数和数据继承了两份，其实我们应该清楚，**这份数据我们只需要一份就可以。**

```c++
#include <iostream>
using namespace std;

class BigBase {
	public:
		int mParam;
		BigBase() {
			mParam = 0;
		}
		void func() {
			cout << "BigBase::func" << endl;
		}
};

class Base1 : public BigBase {

};
class Base2 : public BigBase {

};
class Derived : public Base1, public Base2 {

};

int main() {

	Derived derived;
	// 对“func”的访问不明确
	//derived.func();  //[Error] request for member 'func' is ambiguous
	//cout << derived.mParam << endl; //[Error] request for member 'mParam' is ambiguous

	cout << "derived.Base1::mParam:" << derived.Base1::mParam << endl;
	cout << "derived.Base2::mParam:" << derived.Base2::mParam << endl;
//	derived.Base1::mParam:0
//	derived.Base2::mParam:0
	return 0;
}
```



##### 2.8.6.3. 虚继承

菱形继承的经典问题是由于有两条不同的路径可以访问同一个基类，导致了二义性和资源浪费的问题。为了解决这个问题，C++引入了虚继承（virtual inheritance）的概念。

在虚继承中，基类的继承被标记为`virtual`，这样在派生类中只会保留一份基类的实例，解决了菱形继承问题。让我们通过一个羊驼的例子来说明：

```cpp
#include <iostream>

// 公共基类
class Animal {
public:
    Animal(const std::string& name) : name(name) {}

    void eat() const {
        std::cout << name << " is eating." << std::endl;
    }

    void sleep() const {
        std::cout << name << " is sleeping." << std::endl;
    }

private:
    std::string name;
};

// 继承自Animal的虚基类
class Mammal : virtual public Animal {
public:
    Mammal(const std::string& name) : Animal(name) {}

    void run() const {
        std::cout << name << " is running." << std::endl;
    }
};

// 继承自Animal的虚基类
class Bird : virtual public Animal {
public:
    Bird(const std::string& name) : Animal(name) {}

    void fly() const {
        std::cout << name << " is flying." << std::endl;
    }
};

// 羊驼类同时继承自Mammal和Bird
class Llama : public Mammal, public Bird {
public:
    Llama(const std::string& name) : Animal(name), Mammal(name), Bird(name) {}
};

int main() {
    // 创建羊驼对象
    Llama myLlama("Larry");

    // 通过不同路径访问Animal的成员
    myLlama.eat();   // 通过Mammal路径
    myLlama.sleep(); // 通过Bird路径

    // 通过Mammal和Bird的路径分别访问它们自己的成员
    myLlama.run();   // 通过Mammal路径
    myLlama.fly();   // 通过Bird路径

    return 0;
}
```

在这个例子中，`Mammal` 和 `Bird` 都使用了虚继承，而 `Llama` 类同时继承了这两个虚基类。这样设计避免了菱形继承问题，确保在 `Llama` 中只有一份 `Animal` 的实例。通过虚继承，可以安全地使用多继承而不会引起二义性。

```c++
#include <iostream>
using namespace std;

class BigBase {
	public:
		BigBase() {
			mParam = 0;
		}
		void func() {
			cout << "BigBase::func" << endl;
		}
	public:
		int mParam;
};

class Base1 : virtual public BigBase {};
class Base2 : virtual public BigBase {};
class Derived : public Base1, public Base2 {};

int main() {

	Derived derived;
	//二义性问题解决
	derived.func();
	cout << derived.mParam << endl;
	//输出结果:12
	cout << "Derived size:" << sizeof(Derived) << endl;

	return EXIT_SUCCESS;
}
//Base1，Base2采用虚继承方式继承BigBase,那么BigBase被称为虚基类。
```



## 多态

多态（Polymorphism）是C++中的一个重要概念，它允许使用不同类型的对象通过相同的接口进行操作。C++中的多态性主要通过**虚函数（virtual functions）和虚函数表（vtable）**来实现。**多态分为编译时多态（静态多态）和运行时多态（动态多态）两种。**

在程序中，一个类的引用指向另外一个类的对象，从而产生多种形态。当二者存在直接或者间接的继承关系时，父类引用指向子类的对象，即形成多态。

多态是面向对象三大特性之一，记住继承是多态的前提，如果类与类之间没有继承关系，也不会存在多态。

静态多态和动态多态的区别就是**函数地址是早绑定(静态联编)还是晚绑定(动态联编)。**

+ 如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。
+ 如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。

#### 对象转型

对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。

也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。

```c++
class Animal {
public:
    void bark() {
        cout << "Animal Bark" << endl;
    }
};

class Dog: public Animal {
public:
    void bark() {
        cout << "Dog Bark" << endl;
    }
};

int main(){

    // 父类的引用指向子类的对象
    Dog dog;
    Animal& animal = dog;

    // 向上转型后的对象调用父类中的函数
    animal.bark();

    return 0;
}
```

#### 虚函数

>   上述代码的运行结果是: Animal bark。说明执行的是父类中的bark函数，而非子类中的函数。
>
>   于是现在就有一个问题出现了: 为什么？animal的引用指向的实际上是一个Dog对象，但是为什么会调用父类中的函数实现呢？

解决这个问题，我们需要了解下绑定(捆绑,binding)概念。

>   把函数体与函数调用相联系称为绑定(捆绑，binding)



当绑定在程序运行之前(由编译器和连接器)完成时，称为早绑定(early binding)。

上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译是根据指向对象的指针或引用的类型来选择函数调用。这个时候由于**调用函数的时候使用的是Animal类型，编译器确定了应该调用的bark是Animal::bark的，而不是真正传入的对象Dog::bark。**

解决方法就是迟绑定(迟捆绑,动态绑定,运行时绑定，late binding)，意味着绑定要根据对象的实际类型，发生在运行。

C++语言要实现这种动态绑定，必须有某种机制来确定运行时对象的类型并调用合适的成员函数。对于一种编译语言，编译器并不知道实际的对象类型（编译器并不知道Animal类型的指针或引用指向的实际的对象类型）



**C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。对于特定的函数进行动态绑定，C++要求在基类中声明这个函数的时候使用virtual关键字，动态绑定也就对virtual函数起作用。**

-   **为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要.**
-   **如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的.**
-   **在派生类中virtual函数的重定义称为重写(override).**
-   **virtual关键字只能修饰成员函数.**
-   **构造函数不能为虚函数**

```c++
#include <iostream>
using namespace std;

class Animal {
	public:
		// 将需要动态绑定的函数定义为虚函数
		virtual void bark() {
			cout << "Animal Bark" << endl;
		}
};

class Dog: public Animal {
	public:
		// 在子类中重写虚函数
		void bark() override {
			cout << "Dog Bark" << endl;
		}
};

int main() {

	// 将Dog对象转成父类的对象
	// 这里是向上转型
	Dog dog;
	Animal& animal = dog;

	// 向上转型后的对象调用父类中的函数
	animal.bark();  //Dog Bark

	return 0;
}
```

运行时多态在运行阶段确定使用哪个函数的一种多态性。通过虚函数和基类指针或引用，可以实现运行时多态。

```cpp
#include <iostream>

// 基类
class Shape {
public:
    // 虚函数
    virtual void draw() const {
        std::cout << "Drawing a shape." << std::endl;
    }
};

// 派生类1
class Circle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing a circle." << std::endl;
    }
};

// 派生类2
class Square : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing a square." << std::endl;
    }
};

int main() {
    Circle circle;
    Square square;

    Shape* shapePtr1 = &circle;
    Shape* shapePtr2 = &square;

    shapePtr1->draw(); // 输出：Drawing a circle.
    shapePtr2->draw(); // 输出：Drawing a square.

    return 0;
}

```

- 虚函数是在基类中声明的一个函数，可以在派生类中被重写（覆盖）。通过在函数声明前加上 `virtual` 关键字来定义虚函数。虚函数的调用在运行时决定。
- 虚函数表（vtable）是一个表格，其中存储了类的虚函数的地址。每个包含虚函数的类都有一个对应的虚函数表。当类包含虚函数时，编译器为其生成一个虚函数表。**虚函数表的作用是为每个类创建一个包含其虚函数地址的表格。当通过基类指针调用虚函数时，程序将根据该指针指向的实际对象的虚函数表，找到对应的虚函数的地址，并进行调用。这种机制允许在运行时动态地确定要调用的函数，实现了多态性**。

### 多态的实例

+ 未使用多态实现

```cpp
#include <iostream>
using namespace std;

class SF {
	public:
		void sendPackage() {
			cout << "SF快递为你快速发送包裹" << endl;
		}
};

class EMS {
	public:
		void sendPackage() {
			cout << "EMS快递为您发送包裹，哪里都能送到！" << endl;
		}
};

class JDL {
	public:
		void sendPackage() {
			cout << "JDL快递为您发送包裹，最快当日可达！" << endl;
		}
};

void sendPackage(string company) {
	if (company == "SF") {
		SF *sf = new SF();
		sf->sendPackage();
		delete sf;
	} else if (company == "EMS") {
		EMS *ems = new EMS();
		ems->sendPackage();
		delete ems;
	} else if (company == "JDL") {
		JDL *jdl = new JDL();
		jdl->sendPackage();
		delete jdl;

	}
	// 这里违背了程序设计原则中的开闭原则
	// 开闭原则：对拓展开放、对修改关闭，意义是当有新的功能增加对时候，直接拓展模块，而不是修改现有的实现部分。
}
int main() {
	
	string *name = new string("");
	cin>>*name;
	sendPackage(*name);
	return 0;

}
```

---

+ 使用多态

```cpp
#include <iostream>
#include <string>
using namespace std;

// 声明基类
class DeliveryService {
public:
    virtual void sendPackage() const = 0; // 纯虚函数，必须在派生类中实现
};

// SF类继承自DeliveryService
class SF : public DeliveryService {
public:
    void sendPackage() const override {
        cout << "SF快递为你快速发送包裹" << endl;
    }
};

// EMS类继承自DeliveryService
class EMS : public DeliveryService {
public:
    void sendPackage() const override {
        cout << "EMS快递为您发送包裹，哪里都能送到！" << endl;
    }
};

// JDL类继承自DeliveryService
class JDL : public DeliveryService {
public:
    void sendPackage() const override {
        cout << "JDL快递为您发送包裹，最快当日可达！" << endl;
    }
};

// 使用DeliveryService指针实现多态
void sendPackage(DeliveryService* company) {
    company->sendPackage();
}

int main() {
    // 创建各个快递服务对象
    SF sf;
    EMS ems;
    JDL jdl;

    // 使用多态调用函数
    sendPackage(&sf);
    sendPackage(&ems);
    sendPackage(&jdl);

    return 0;
}

```

#### 纯虚函数与抽象类

在设计程序时，**常常希望基类仅仅作为其派生类的一个接口。**这就是说，**仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。**同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。



> 我们可以设计一个交通工具类，提供最基础的运输的功能。我们在使用到交通工具的时候，往往并不是寻求交通工具的对象，而是寻求的交通工具子类的对象，例如公交车、例如地铁、例如共享单车等。而我们需要的其实是在这些子类中的运输功能实现。因此，父类交通工具类中的运输功能怎么去实现没有意义。




纯虚函数使用virtual来修饰一个函数，并且实现部分直接设置为0。

```cpp
virtual void test() = 0;
```

**如果一个类中包含了纯虚函数，那么这个类也自动的编程了抽象类了。抽象类无法实例化对象，并且子类必须重写实现父类中的纯虚函数，否则子类也是抽象类。**

```c++
#include <iostream>
using namespace std;

class TrafficTools {
	public:
		// 定义纯虚函数，此时的类是抽象类
		virtual void transport() const = 0;
};

class Bus: public TrafficTools {
	public:
		void transport() const override  {
			cout << "公交车运输乘客" << endl;
		}
};

class Subway: public TrafficTools {
	public:
		void transport() const override {
			cout << "地铁运输乘客" << endl;
		}
};

void useTrafficTools(TrafficTools& trafficTools) {
	trafficTools.transport();
}

int main() {
	// 抽象类无法实例化对象
	// new TrafficTools;

	useTrafficTools(*(new Bus));
	useTrafficTools(*(new Subway));
	return 0;
}
```



### 纯虚函数与多继承

多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。
绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，C++中没有接口的概念，但是可以通过纯虚函数实现接口。

接口类中只有函数原型定义，没有任何数据定义。

多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。
注意:除了析构函数外，其他声明都是纯虚函数。

```c++
#include <iostream>
using namespace std;

// 定义一个功能集合，厨师类
class Cooker {
	public:
		virtual void buyFood() = 0;
		virtual void cook() = 0;
		virtual void eat() = 0;
};
// 定义一个功能集合，保姆类
class Maid {
	public:
		virtual void cook() = 0;
		virtual void clean() = 0;
		virtual void wash() = 0;
};

// 使得人类同时具备这两种功能
class Person: public Cooker, public Maid {
	public:
		// 对继承到的纯虚函数进行实现
		void buyFood() override {
			cout << "买菜" << endl;
		}
		void cook() override {
			cout << "做饭" << endl;
		}
		void eat() override {
			cout << "吃饭" << endl;
		}
		void clean() override {
			cout << "扫地" << endl;
		}
		void wash() override {
			cout << "洗衣服" << endl;
		}
};


int main() {

	Person xiaoming;
	xiaoming.buyFood();
	xiaoming.cook();
	xiaoming.eat();
	xiaoming.wash();
	xiaoming.clean();

	return 0;
}
```



### 虚析构函数

析构函数是对象生命周期的终点，在对象被销毁之前调用。在析构函数中，我们一般会进行资源的释放、空间的销毁的操作。

例如，在一个类中有指向堆空间内存的指针，我们需要通过这样的指针来销毁对应的堆空间。但是，在多态中，父类的引用可以指向子类的对象，那么我们在使用父类的引用来销毁空间的话，就有可能会出现子类中引用的堆空间无法销毁的情况，造成内存泄漏。而解决方案就是为父类添加虚析构函数。

```c++
#include <iostream>
using namespace std;

class Animal {
	public:
		virtual ~Animal() {
			cout << "父类的析构函数执行了" << endl;
		}
};

class Person: public Animal {
	public:
		int* n;

		Person() {
			n = new int(10);
		}

		~Person() override {
			cout << "子类的析构函数执行了" << endl;
			if (n != nullptr) {
				delete n;
				n = nullptr;
			}
		}
};

int main() {

	Animal* animal = new Person();
	// 如果没有虚析构函数的话，这里通过animal来销毁空间，的确可以把Person开辟的堆空间给销毁掉
	// 但是，由于只会触发父类中的析构函数，因此无法将Person属性n开辟的堆空间给销毁掉，造成内存泄漏
	// 解决方案：将父类的析构函数作为虚析构函数，完成动态绑定
	delete animal;

	return 0;
}
```

虚析构函数也可以做成纯虚析构函数，如果一个类中包含了纯虚析构函数，那么这个类依然是一个抽象类，无法实例化对象。

+ 如果一个类的目的不是为了实现多态，仅仅是作为一个基类来使用，那么无需将析构函数设置为虚析构函数。

+ 如果一个类的目的就是为了实现多态的，那么这个类的析构函数就有必要设置为虚析构函数。

### 2.10. 结构体

#### 2.10.1. 结构体的定义与使用

在C++中，还有一种用户自定义的数据类型，结构体。结构体的定义与使用基本与类相同。

```c++
// 定义结构体
struct Student {
	// 结构体中定义的属性
	string name;
	int age;

	// 结构体中的构造函数
	Student() {
		name = "";
		age = 0;
	}

	Student(string name, int age): name(name), age(age) {}

	// 结构体中的函数
	void study() const {
		cout << name << "正在努力学习" << endl;
	}

	// 结构体中的析构函数
	~Student() {
		cout << "结构体析构函数" << endl;
	}
};

int main() {
	// 创建结构体对象
	// 创建结构体对象时候的关键字struct可以省略不写
	struct Student student;
	// 访问成员
	student.name = "zhangsan";
	student.age = 18;
	student.study();

	// 通过有参构造创建结构体对象
	struct Student xiaoming("xiaoming", 12);
	struct Student xiaohei = Student("xiaohei", 11);
	struct Student xiaobai = {"xiaobai", 10};

	// 在堆上创建结构体对象
	struct Student* xiaoli = new Student("xiaoli", 11);
	delete xiaoli;

	return 0;
}
```



#### 2.10.2. 结构体与类的区别

C++对结构体进行了很多的拓展，是的C++对结构体用于与类几乎相同的功能：可以设计属性、函数，可以设计构造、析构，甚至可以有继承，可以有多态。现在看来C++的结构体与类的区别，主要是一点：**默认的访问权限不同**

-   类成员默认的访问权限是private
-   结构体成员默认的访问权限是public

## 模板

###  模板的介绍

c++提供了函数模板(function template)。所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。

c++提供两种模板机制：**函数模板**和**类模板**

总结：
	模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。
	模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。



### 函数模板

####  函数模板的定义

```c++
// 实现两个int变量的值的交换
void mySwap(int& a, int& b) {
    int tmp = a;
    a = b;
    b = tmp;
}
// 两个double变量的值的交换
void mySwap(double& a, double& b) {
    double tmp = a;
    a = b;
    b = tmp;
}
```

```c++
// 定义函数模板
// template: 模板关键字
// typename: 定义虚拟类型关键字，也可以使用class
// T: 定义的一个虚拟的类型，在这里暂不确定是什么类型，等到调用这个函数的时候就可以确定了
template<typename T>
void mySwap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}
```



####  函数模板的使用

```c++
template<class T>
void mySwap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}

int main() {
    int a = 10, b = 20;
    double x = 3.14, y = 0.99;

    // 1. 显式指定类型
    mySwap<int>(a, b);

    // 2. 可以自动根据实参的类型进行推导
    mySwap(a, b);       // 这里调用的mySwap中，类型T被推导为int类型
    mySwap(x, y);       // 这里调用的mySwap中，类型T被推导为double类型

    // 注意事项: 类型推导的时候，需要保证一致性。不满足一致性无法推导。
    // 例如 mySwap(a, y);     
    // 第一个实参a是int类型，推导T的类型为int；第二个实参y是double类型，推导T的类型为double；不一致

    return 0;
}
```



####  函数模板案例

```c++
// 需求：定义一个模板函数，实现对一个数组中对元素进行升序排序
template<class T>
void mySort(T array[], int len) {
    for (int i = 0; i < len - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (array[minIndex] > array[j]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            T tmp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = tmp;
        }
    }
}

// 需求：定义一个模板函数，实现将一个数组中对元素拼接成为字符串返回
template<class T>
void showArray(T array[], int len) {
    if (len == 0) {
        cout << "[]" << endl;
        return;
    }
    cout << "[";
    for (int i = 0; i < len - 1; i++) {
        cout << array[i] << ", ";
    }
    cout << array[len - 1] << "]" << endl;
}

int main() {

    // 定义一个int[]
    int array1[] = {1, 3, 5, 7, 9, 0, 8, 6, 4, 2};
    int len1 = sizeof(array1) / sizeof(int);
    mySort(array1, len1);
    showArray(array1, len1);

    // 定义一个double[]
    double array2[] = {3.14, 9.28, 3, 3.44, -9.2, 8.22};
    int len2 = sizeof(array2) / sizeof(double);
    mySort(array2, len2);
    showArray(array2, len2);

    // 定义一个char[]
    char array3[] = {'a', 'l', '1', 'm', 'k'};
    int len3 = sizeof(array3) / sizeof(char);
    mySort(array3, len3);
    showArray(array3, len3);

    return 0;
}
```



#### 函数模板与普通函数

函数模板和普通函数在调用的时候，需要注意：

-   普通函数调用，是可以发生自动的类型转换的；函数模板调用，是不可以发生自动的类型转换的
-   如果调用函数的时候，实参既可以匹配普通函数，又可以匹配函数模板，则优先匹配普通函数

```c++
// 定义一个函数模板
template<class T>
int myPlus(const T& n1, const T& n2) {
    return n1 + n2;
}

int myPlus(int n1, int n2) {
    return n1 + n2;
}

int main() {

    // 调用普通函数，类型可以自动转换
    int n1 = 10;
    char c = 'a';
    myPlus(n1, c);      // 这里进行了类型的自动转换，c是char类型，被转型成了int类型。

    // 调用函数模板，类型不可以自动转换
    // myPlus(n1, c);         // 这里直接错误，因为这里不允许类型的转换。

    // 如果实参既可以匹配普通函数 ，又可以匹配函数参数。则优先普通函数调用。
    myPlus(10, 20);

    return 0;
}
```



#### 函数模板的局限性

函数模板虽然很通用，但是并不是万能的，有时候也会有不适配的情况出现。

```c++
template<class T>
bool compare(const T& t1, const T& t2) {
    return t1 > t2;
}
```

对于上述的函数模板来说，如果是比较整型、浮点型甚至字符类型的数据都是没有问题的。可是如果我设置为Person类型呢？两个Person对象无法使用>进行比较，这里自然也就出问题了。

那么如何解决这样的问题呢？

1.   重载运算符，重载>运算符。
2.   通过函数模板的重载来解决。

函数模板的重载，就是为了解决特定类型的对象的问题，通过函数模板的重载，可以为这些特定的数据类型提供具像化的模板。

```c++
#include <iostream>
using namespace std;

class Person {
	public:
		int age;
};

template<class T>
bool compare(const T& t1, const T& t2) {
	return t1 > t2;
}

template<> //对 compare 函数的特化，告诉编译器为 compare 函数的模板版本提供特定于 Person 类型的实现。
bool compare<Person>(const Person& p1, const Person& p2) {
	return p1.age > p2.age;
}


int main() {

	Person p1;
	p1.age = 15;

	Person p2;
	p2.age = 12;

	cout << compare(p1, p2) << endl;

	return 0;
}
```

### 类模板

####  类模板的定义

类模板和函数模板的定义和使用基本是一样的，如何定义函数模板，就如何定义类模板。但是类模板与函数模板还是有点区别的：

- 类模板不能自动类型推导。

```c++
template<class T1, class T2 = int>
class NumberOperator {
public:
    T1 num1;
    T2 num2;

    void cal() {
        cout << num1 + num2 << endl;
    }
};

int main() {

    // 创建对象，不能类型推导，只能自己指定类型
    NumberOperator<int, int> op1;
    op1.num1 = 10;
    op1.num2 = 20;
    op1.cal();

    // 创建对象
    NumberOperator<double> op2;
    op2.num1 = 3.14;
    op2.num2 = 10;
    op2.cal();

    return 0;
}
```



####  类模板做函数参数

```c++
template<class T1, class T2 = int>
class NumberOperation {
public:
    T1 num1;
    T2 num2;

    void cal() {
        cout << num1 + num2 << endl;
    }
};

// 参数中明确模板类
void useNumberOperation(NumberOperation<int, int>& op) {
    op.cal();
}

// 参数中使用模板
template<typename T1, typename T2>
void useNumberOperation02(NumberOperation<T1, T2>& op) {
    op.cal();
}

int main() {

    // 参数明确模板类调用
    NumberOperation<int, int> op;
    op.num1 = 10;
    op.num2 = 20;
    useNumberOperation(op);

    // 参数模板
    useNumberOperation02(op);
    NumberOperation<double, int> op2;
    op2.num1 = 10.5;
    op2.num2 = 5;
    useNumberOperation02(op2);

    return 0;
}
```



####  类模板继承

```c++
// 定义模板类
template<typename T>
class Animal {
public:
    T arg;
};

// 普通类继承模板类的时候，必须明确指定类型
class Dog: Animal<int> {
    // 这里继承到的arg的数据类型是int
};

template<typename E>
class Person: Animal<E> {
    // 这里继承到的arg的数据类型是E
};
```



####  类模板中的成员函数创建时机

类模板中的成员函数在编译的时候是不会创建的，是在调用这个函数的时候创建。

```c++
class Dog {
public:
    void bark() { cout << "汪汪" << endl; }
}

class Cat {
public:
    void sleep() { cout << "呼呼" << endl; }
}

template<typename T>
class Person {
public:
    T pet;
    
    void makeBark() {
        pet.bark();
    }
    
    void makeSleep() {
        pet.sleep();
    }
}

int main() {
    // 在类设计完成后，直接编译程序，发现是没有问题的。
    
    // 调用makeBark函数的时候，也是没有问题的，可以正常调用。
    Person<Dog> xiaobai;
    xiaobai.makeBark();
    
    // 调用makeSleep函数的时候就出问题了，不能调用了！
	xiaobai.makeSleep();
    
    // 原因：类模板中的成员函数是在调用的时候才会创建的！
    // 因为在编译的时候，只是知道有一个对象是obj，但是具体是什么类型，不知道！
    // 在调用makeBark的时候，创建了这个函数，而我们设置的类型是Dog类型，没有问题，可以正常执行
    // 在调用makeSleep的时候，创建了这个函数，判断pet的类型是Dog类型，而在Dog类中不存在sleep函数，因此就报错了。
    
    return 0;
}
```



#### 类模板类外实现

```c++
template<typename T, typename M>
class NumberCalculator {
private:
    T n1;
    M n2;
public:
    NumberCalculator() {}
    NumberCalculator(T n1, M n2);
    
    void add();
};
// 构造函数类外实现
template<typename T, typename M>
NumberCalculator<T, M>::NumberCalculator(T n1, M n2) {
    this->n1 = n1;
    this->n2 = n2;
}
// 普通函数类外实现
template<typename T, typename M>
NumberCalculator<T, M>::add() {
    cout << n1 + n2 << endl;
}
```



#### 类模板头文件和原文件分离问题

我们在写程序的时候，很多时候都是需要将类的声明和实现分开来写。将类的声明部分写到.h文件中，将类的实现部分写在.cpp文件中。在使用到这个类的时候，直接包含.h文件即可。但是，如果是一个模板类，这样做是有问题的。

**NumberCalculator.h**

```c++
#pragma once

template<typename T, typename M>
class NumberCalculator {
private:
    T n1;
    M n2;
public:
    NumberCalculator() {}
    NumberCalculator(T n1, M n2);

    void add();
};
```

**NumberCalculator.cpp**

```c++
#include <iostream>
#include "NumberCalculator.h"
using namespace std;

// 构造函数类外实现
template<typename T, typename M>
NumberCalculator<T, M>::NumberCalculator(T n1, M n2) {
    this->n1 = n1;
    this->n2 = n2;
}
// 普通函数类外实现
template<typename T, typename M>
void NumberCalculator<T, M>::add() {
    cout << n1 + n2 << endl;
}
```

```c++
int main() {
    // 通过无参构造创建对象，没有问题
    NumberCalculator<int, int> cal1;
    // 通过有参构造创建对象，出问题了
    NumberCalculator<int, int> cal2(10, 20);
    
    // 问题出现原因：
    // 我们虽然引入了.h文件，但是模板类中的函数是在调用的时候才会创建的，因此在编译阶段也不会管对应的.cpp文件中的实现部分。
    // 而到了使用到这个函数的时候，发现这个函数已经创建了，但是没有实现。因此就报错了。
    // 相当于我们只是在.h中声明了函数，但是并没有实现。
    //
    // 如何解决问题：
    // 1. 使用#include引入cpp文件
    // 2. 将类的声明和实现放到一个文件中
    //    这个文件我们习惯上会定义为.hpp文件，但是并不是绝对的，只是一个习惯和约定的问题。
}
```



####  类模板遇到友元

```c++
// 全局友元函数类外实现-03：定义类
template<typename T, typename M>
class NumberCalculator;

// 全局友元函数类外实现-02：在类之前定义
template<typename T, typename M>
void printNumberCalculator(const NumberCalculator<T, M>& op) {
    cout << "n1 = " << op.n1 << ", n2 = " << op.n2 << endl;
}

template<typename T, typename M>
class NumberCalculator {
    // 全局友元函数类内实现，无需进行什么处理，直接在这里写实现即可。
    /*
    friend void printNumberCalculator(const NumberCalculator<T, M>& op) {
        cout << "n1 = " << op.n1 << ", n2 = " << op.n2 << endl;
    }
     */

    // 全局友元函数类外实现—01：在函数的后面添加一对尖括号，表示一个模板函数
    friend void printNumberCalculator<>(const NumberCalculator<T, M>& op);
private:
    T n1;
    M n2;
public:
    NumberCalculator();
    NumberCalculator(T n1, M n2);
};

template<typename T, typename M>
NumberCalculator<T, M>::NumberCalculator(T n1, M n2) {
    this->n1 = n1;
    this->n2 = n2;
}

template<typename T, typename M>
NumberCalculator<T, M>::NumberCalculator() = default;


int main() {

    NumberCalculator<int, int> op(10, 20);

    printNumberCalculator(op);

    return 0;
}
```

